---
title: "exercise2"
output: html_document
date: '2022-04-22'
---

# Exercise Week 2

```{r}
rm(list=ls())
library(tidyverse)
library(sf)
library(terra)
library(lubridate)
library(gridExtra)
library(zoo)
```

# Task 1
```{r}
ws <- read_delim("wildschwein_BE_2056.csv")

ws_sf <- st_as_sf(ws, coords = c("E", "N"), crs = 2056, remove = FALSE)
```



--------------------------------------------------------------------------------



# Task 2 - Getting an overview

Calculate the time difference between subsequent rows 

```{r}
sum(is.na(ws_sf$DatetimeUTC)) # no na's

ws_sf <- group_by(ws_sf, TierID)

ws_sf <- mutate(ws_sf, timelag = as.integer(difftime(lead(DatetimeUTC), DatetimeUTC, units = "secs")))

# NA's ?
summary(ws_sf$timelag)
# 3 NA's, as expected from shifts in 3 groups
```


    How many individuals were tracked?
    For how long were the individuals tracked? Are there gaps?
    Were all individuals tracked concurrently or sequentially?


```{r}
ggplot(ws_sf, aes(x = DatetimeUTC, y = TierID)) +
    geom_point()
```
- 3 Animals were tracked over a period of approx. 8 months, with one individual being tracked for approx. 1 year. 
- there seem to be no gaps
- they were tracked concurrently


    What is the temporal sampling interval between the locations?

```{r}
range(ws_sf$timelag)
nrow(filter(ws_sf, timelag >= 27000))

ws_sf %>% 
    filter(timelag <= 27000) %>%
    ggplot(aes(x = timelag)) +
    geom_histogram(binwidth = 60) +
    scale_y_log10()

# for visualization purpose 8 timelag values above 27000 were excluded in this histogram

```

-> temporal sampling intervals are distributed across a range between 12
& 60367 seconds, with some peaks between 0 & 6000 seconds and another large peak around 10000 seconds




--------------------------------------------------------------------------------



# Task 3 - Deriving movement parameters I: Speed

So far our trajectories only consist of a list of time-stamped spatial locations. So let’s calculate the animal’s steplength based on the Euclidean distance between two subsequent locations.


```{r}
ws_sf$steplength <- sqrt(((ws_sf$E - lead(ws_sf$E))**2) + ((ws_sf$N - lead(ws_sf$N))**2)) 

summary(ws_sf$steplength)
```


```{r}
ws_sf$speed <- (ws_sf$steplength / ws_sf$timelag)

summary(ws_sf$speed)
```

--> The speed unit is in meters/seconds (m/S)



--------------------------------------------------------------------------------



# Task 4 - Cross-scale movement analysis

```{r}
caro <- read_delim("caro60.csv")
caro <- st_as_sf(caro, coords = c("E", "N"), crs = 2056, remove = FALSE)
class(caro)
```

    Manually reduce the granularity of our sampling interval by selecting every 3rd, 6th and 9th position 

# every 3rd
```{r}
seq3 <- seq(1,nrow(caro),3)
caro_3 <- caro %>% slice(seq3)
```


# every 6th
```{r}
seq6 <- seq(1,nrow(caro),6)
caro_6 <- caro %>% slice(seq6)
```


# every 9th
```{r}
seq9 <- seq(1,nrow(caro),9)
caro_9 <- caro %>% slice(seq9)
```


    Now calculate timelag, steplength and speed for these data sets, just as you did in the last task.  

```{r}
# function to derive timelag, steplenght & speed
derivates <- function(sf_data){
    # timelag
    sf_data <- mutate(sf_data, timelag = as.integer(difftime(lead(sf_data$DatetimeUTC), sf_data$DatetimeUTC, units = "secs")))
    # steplength
    sf_data$steplength <- sqrt(((sf_data$E - lead(sf_data$E))**2) + ((sf_data$N - lead(sf_data$N))**2)) 
    # speed
    sf_data$speed <- (sf_data$steplength / sf_data$timelag)
    
    sf_data
}
```

```{r}
caro   <- derivates(caro)
caro_3 <- derivates(caro_3)
caro_6 <- derivates(caro_6)
caro_9 <- derivates(caro_9)
```


    To finish the task, compare the speeds visually in a line plot and also visualize the trajectories in a map (see examples below).

    
```{r}
# functions to produce the plots
traj_map <- function(original, resampled, E, N){
    plot <- ggplot() + 
        geom_path( data = original,  mapping = aes({{E}}, {{N}}, colour = "cyan"), size = 0.8, alpha = 0.2) +
        geom_point(data = original,  mapping = aes({{E}}, {{N}}, colour = "cyan"), alpha = 0.2) + 
        geom_path( data = resampled, mapping = aes({{E}}, {{N}}, colour = "red"),  size = 1) +
        geom_point(data = resampled, mapping = aes({{E}}, {{N}}, colour = "red"),  size = 1.2) +
        theme_bw() +
        theme(legend.justification = "right") +
        theme(plot.title = element_text(face = "bold", hjust = 0.5), legend.title = element_text(face = "bold", hjust = 0.5))

    plot
}
```

```{r}
# 3 minute interval
traj_3 <- traj_map(caro, caro_3, E, N) + 
    scale_colour_discrete(name = "Trajectory", labels = c("1 minute", "3 minutes")) +
    labs(title = "1-Minute vs. 3-Minute sampling interval") 

# 6 minute interval
traj_6 <- traj_map(caro, caro_6, E, N) + 
    scale_colour_discrete(name = "Trajectory", labels = c("1 minute", "6 minutes")) +
    labs(title = "1-Minute vs. 6-Minute sampling interval") 

# 9 minute interval
traj_9 <- traj_map(caro, caro_9, E, N) + 
    scale_colour_discrete(name = "Trajectory", labels = c("1 minute", "9 minutes")) +
    labs(title = "1-Minute vs. 9-Minute sampling interval") 
```

```{r, fig.height=12, fig.width=7}
grid.arrange(traj_3, traj_6, traj_9, ncol = 1)


```


    Interpret the line plot, what do the different lines for the different temporal granularities tell you?


```{r, fig.height=6, fig.width=12}
ggplot(mapping = aes(x = DatetimeUTC, y = speed)) +
    geom_line(data = caro, aes(color = "1 minute"),    size = 1) +
    geom_line(data = caro_3, aes(color = "3 minutes"), size = 1) +
    geom_line(data = caro_6, aes(color = "6 minutes"), size = 1) +
    geom_line(data = caro_6, aes(color = "9 minutes"), size = 1) +
    scale_colour_discrete(name = "Interval") +
    labs(title = "Speed at different sampling intervals") +
    theme(plot.title = element_text(face = "bold", hjust = 0.5), legend.title = element_text(face = "bold", hjust = 0.5))

```

-> It appears as with increasing interval, the speed-peaks decrease, almost like it has "less sensitivity" to changes in speed. This may be because over a larger interval, the step length may (de- or) increase, as position fixes rearrange the perceived path the animal took. It may not represent phases where the animal rested or showed high activity, while during an interval the animal could also have gone 10 meters north and 20 meters south, which would be reflected as only 10m of distance covered during that interval, while in reality 30m where covered.  

-> So, the scale (or granularity) we choose really depends on what the question is, as the granularity can drastically change the absolute values for speed and its context. 

--------------------------------------------------------------------------------


# Task 5: Deriving movement parameters II: Rolling window functions

A different approach would be to smoothen the derived parameters using a moving window function. The zoo package offers a variate of moving window functions (roll_*). Install this package, load it into the session and use the function roll_mean() to smooth the calculated speed. Familiarise yourself with this function by working on some dummy data

```{r}
series <- seq(1,20)
series
rollmean(series, k = 3, fill = NA, align = "left")
rollmean(series, k = 4, fill = NA, align = "left")
rollmean(series, k = 10, fill = NA, align = "left")
```

Now run rollmeanon the speed variable of the subset (caro). Visualize the output from your moving windows and compare different window sizes (k =).

```{r}
caro_k3 <- rollmean(caro$speed, k = 3, fill = NA, align = "left")
caro_k6 <- rollmean(caro$speed, k = 6, fill = NA, align = "left")
caro_k9 <- rollmean(caro$speed, k = 9, fill = NA, align = "left")
```

```{r, fig.height=5, fig.width=11}
ggplot(caro, aes(x = DatetimeUTC, y = speed)) +
    geom_line(aes(colour = "k = 1"), size = 1) +
    geom_line(aes(y = caro_k3, colour = "k = 3"), size = 1) +
    geom_line(aes(y = caro_k6, colour = "k = 6"), size = 1) +
    geom_line(aes(y = caro_k9, colour = "k = 9"), size = 1) +
    scale_colour_discrete(name = "Length of \n rolling window") +
    labs(title = "Speed smoothened by using 'rolling window functions'") +
    theme(plot.title = element_text(face = "bold", hjust = 0.5), legend.title = element_text(face = "bold", hjust = 0.5))
    
```

--> The plots look relatively similar as with cross-scale analysis (see above), where with increasing interval, the peaks get smaller. However, it seems as with increasing rolling window, there are more preserved peaks at low speed values, compared to the cross-scale analysis before with higher sampling intervals. With this method, the trajectories for each window stayed the same, which wasn't the case before -> the speed was smoothened over the same distances.

